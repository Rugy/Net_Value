<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Working Tittle</title>
	<script src="js/phaser.js"></script>
	<style type="text/css">
		body {
			margin: 0;
		}
	</style>
</head>
<body>

<script type="text/javascript">

	var width = window.screen.width * 0.9;
	var height = window.screen.height * 0.75;
	var marker;

	// Tiles
	var tileSize = 64;
	var tileCount = 1;
	var startingTile;

	// Resources
	var resourceSize = 16;
	var resourcePerAxis = tileSize / resourceSize;

	// Entities
	var buildings;
	var resources;

	var config = {
		type: Phaser.AUTO,
		width: width,
		height: height,
		physics: {
				default: 'arcade',
				arcade: {
						debug: false
				}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		}
	};
	var game = new Phaser.Game(config);

	function preload() {
		this.load.image("tiles", "./img/ground.png?v=1");
		this.load.image("house", "./img/house.png?v=1");
		this.load.spritesheet("resources", "./img/resources.png?v=1", {frameWidth: resourceSize, frameHeight: resourceSize});
	}

	function create() {
		buildings = this.physics.add.staticGroup();
		resources = this.physics.add.staticGroup();

		let level = [];

		for (let i = 0; i < height / tileSize; i++) {
			level.push([]);

			for (let j = 0; j < width / tileSize; j++) {
				level[i].push(0);
			}
		}

		map = this.make.tilemap({ data: level, tileWidth: tileSize, tileHeight: tileSize });
		let tiles = map.addTilesetImage("tiles");
		let layer = map.createDynamicLayer(0, tiles, 0, 0);

    marker = this.add.graphics();
    marker.lineStyle(3, 0x99f, 1);
    marker.strokeRect(0, 0, resourceSize, resourceSize);

		startingTile = createTile(2, 2, 2);

		map.forEachTile(function (tile) {
			tile.clickValue = Math.floor(Math.random() * 100 + 1);
		});

	}

	function update() {
    var worldPoint = this.input.activePointer.positionToCamera(this.cameras.main);

    var pointerTileX = map.worldToTileX(worldPoint.x);
    var pointerTileY = map.worldToTileY(worldPoint.y);
		var pointerX = worldPoint.x;
		var pointerY = worldPoint.y;

    var tile = map.getTileAt(map.worldToTileX(worldPoint.x), map.worldToTileY(worldPoint.y));

		if (tile.isDiscovered) {
			marker.setVisible(true);
	    marker.x = pointerX - pointerX % resourceSize;
	    marker.y = pointerY - pointerY % resourceSize;
		} else {
			marker.setVisible(false);
		}

    if (this.input.manager.activePointer.isDown && tile && tile.isDiscovered && tile.isEmpty) {
		 	// buildings.create(pointerTileX * tileSize + tileSize / 2, pointerTileY * tileSize + tileSize / 2, "house");
			// tile.isEmpty = false;
    }
		if (this.input.manager.activePointer.isDown && tile && !tile.isDiscovered) {
			tile.isDiscovered = true;
			createTile(2, pointerTileX, pointerTileY);
		}
	}

	function createTile(layout, tileX, tileY) {
		tile = map.putTileAt(layout, tileX, tileY);
		tile.isDiscovered = true;
		tile.isEmpty = true;
		tile.resources = [];
		tile.freeFields = Array.from(Array(Math.pow(tileSize / resourceSize, 2)).keys());

		for (let i = 0; i < 4; i++) {
			var fieldId = tile.freeFields[Math.floor(Math.random() * tile.freeFields.length)];
			tile.freeFields = tile.freeFields.filter(i => i != fieldId);

			let xLoc = tile.pixelX + (fieldId % resourcePerAxis) * resourceSize + resourceSize / 2;
			let yLoc = tile.pixelY + (Math.floor(fieldId / resourcePerAxis)) * resourceSize + resourceSize / 2;

			tile.resources.push(resources.create(xLoc, yLoc, "resources", weightedRandom([0.25, 0.75])));
		}

		return tile;
	}

	function weightedRandom(weights) {
		if (!weights || weights.length < 1) {
			return;
		}

		var number = Math.random();
		var segmentSum = weights[0];
		var weightSegment = 0;

		for (var i = 1; i < weights.length; i++){
			if (number > segmentSum) {
				segmentSum += weights[i];
				weightSegment++;
			} else {
				break;
			}
		}

		return weightSegment;
	}

</script>

</body>
</html>
